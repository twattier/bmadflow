# Story 1.6: Implement "Hello BMADFlow" End-to-End Integration

## Status

Draft

## Story

**As a** developer,
**I want** a complete end-to-end integration with a backend `/api/hello` endpoint, frontend API integration, and Playwright E2E test,
**so that** I have a validated full-stack application demonstrating frontend-backend-database connectivity with automated testing.

## Acceptance Criteria

1. **Backend /api/hello Endpoint Implemented**:
   - [ ] `GET /api/hello` endpoint created in backend
   - [ ] Endpoint returns JSON: `{"message": "Hello BMADFlow", "status": "ok", "timestamp": "..."}`
   - [ ] Endpoint accessible at `http://localhost:8000/api/hello`
   - [ ] Endpoint documented in OpenAPI/Swagger at `/docs`

2. **Frontend API Integration**:
   - [ ] Axios client configured with backend base URL
   - [ ] Dashboard page fetches `/api/hello` endpoint on mount
   - [ ] API response message displayed on Dashboard page
   - [ ] Loading state shown while fetching
   - [ ] Error handling implemented for API failures

3. **Playwright E2E Test Validates Full Stack**:
   - [ ] Playwright test navigates to `http://localhost:3000`
   - [ ] Test verifies "Hello BMADFlow" message from API displays on page
   - [ ] Test captures screenshot of Dashboard page
   - [ ] Test passes successfully validating E2E integration
   - [ ] Test executable with `npm run test:e2e`

4. **README Updated with Deployment Instructions**:
   - [ ] Full Docker deployment instructions added
   - [ ] Hybrid deployment instructions added
   - [ ] Prerequisites documented (Docker, Python, Node.js, Ollama)
   - [ ] Quick start commands documented
   - [ ] Testing commands documented

5. **Epic 1 Complete - Full Stack Validated**:
   - [ ] Run `docker-compose up` displays "Hello BMADFlow" message in browser
   - [ ] Backend `/api/hello` returns successful response
   - [ ] Frontend displays API response data
   - [ ] E2E test passes validating integration
   - [ ] All Epic 1 acceptance criteria met

## Tasks / Subtasks

- [ ] **Task 1: Create Backend /api/hello Endpoint** (AC: 1)
  - [ ] Create `backend/app/api/v1/hello.py` router
  - [ ] Implement `GET /hello` endpoint returning JSON response
  - [ ] Include message, status, and timestamp in response
  - [ ] Register hello router in `main.py` with `/api` prefix
  - [ ] Test endpoint: `curl http://localhost:8000/api/hello`

- [ ] **Task 2: Configure Frontend Axios Client** (AC: 2)
  - [ ] Create `frontend/src/api/client.ts` with Axios instance
  - [ ] Configure base URL from `VITE_BACKEND_URL` environment variable
  - [ ] Add request/response interceptors for error handling
  - [ ] Set default headers and timeout

- [ ] **Task 3: Create API Service for Hello Endpoint** (AC: 2)
  - [ ] Create `frontend/src/api/services/helloService.ts`
  - [ ] Implement `getHelloMessage()` function calling `/api/hello`
  - [ ] Define TypeScript interface for response type
  - [ ] Export service function

- [ ] **Task 4: Integrate API Call in Dashboard Component** (AC: 2)
  - [ ] Update `frontend/src/pages/Dashboard.tsx`
  - [ ] Use `useEffect` hook to fetch hello message on component mount
  - [ ] Display API response message using useState
  - [ ] Add loading state: "Loading..."
  - [ ] Add error handling: Display error message if API fails
  - [ ] Update UI to show message from backend instead of hardcoded text

- [ ] **Task 5: Create Playwright E2E Test** (AC: 3)
  - [ ] Install Playwright: `cd frontend && npx playwright install`
  - [ ] Create `frontend/tests/e2e/hello-bmadflow.spec.ts`
  - [ ] Write test: Navigate to Dashboard, verify message displays
  - [ ] Capture screenshot of Dashboard page
  - [ ] Add `test:e2e` script to `package.json`: `playwright test`
  - [ ] Run test and verify it passes

- [ ] **Task 6: Update Root README.md** (AC: 4)
  - [ ] Add "Quick Start - Full Docker" section with `docker-compose up` command
  - [ ] Add "Quick Start - Hybrid Mode" section with separate backend/frontend commands
  - [ ] Document prerequisites: Docker Desktop, Python 3.11+, Node.js 18+, Ollama
  - [ ] Add "Verify Deployment" section with health check commands
  - [ ] Add "Running Tests" section with E2E test command
  - [ ] Link to detailed architecture docs

- [ ] **Task 7: Validate Epic 1 Completion** (AC: 5)
  - [ ] Start all services: `docker-compose up`
  - [ ] Access frontend: `http://localhost:3000`
  - [ ] Verify "Hello BMADFlow" message displays (from API)
  - [ ] Test backend health: `curl http://localhost:8000/api/health`
  - [ ] Test hello endpoint: `curl http://localhost:8000/api/hello`
  - [ ] Run E2E test: `cd frontend && npm run test:e2e`
  - [ ] Verify all Epic 1 acceptance criteria met

## Dev Notes

### Backend Hello Endpoint Implementation

**Hello Router** (backend/app/api/v1/hello.py):
```python
from fastapi import APIRouter
from datetime import datetime

router = APIRouter()

@router.get("/hello")
async def hello():
    """
    Hello endpoint demonstrating full-stack integration.
    Returns a welcome message with timestamp.
    """
    return {
        "message": "Hello BMADFlow",
        "status": "ok",
        "timestamp": datetime.utcnow().isoformat()
    }
```

[Source: architecture/backend-architecture.md#api-layer-routes-controllers]

**Register Router** (backend/app/main.py):
```python
from app.api.v1 import health, hello

app.include_router(health.router, prefix="/api", tags=["health"])
app.include_router(hello.router, prefix="/api", tags=["hello"])
```

### Frontend Axios Client Configuration

**API Client** (frontend/src/api/client.ts):
```typescript
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_BACKEND_URL || 'http://localhost:8000';

export const apiClient = axios.create({
  baseURL: `${API_BASE_URL}/api`,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 30000, // 30s timeout
});

// Request interceptor (for future auth tokens)
apiClient.interceptors.request.use(
  (config) => {
    // Add auth token if needed
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor (global error handling)
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 404) {
      console.error('Resource not found:', error.response.data);
    } else if (error.response?.status === 500) {
      console.error('Server error:', error.response.data);
    }
    return Promise.reject(error);
  }
);
```

[Source: architecture/frontend-architecture.md#api-layer-hooks-services]

### Frontend Hello Service

**Hello Service** (frontend/src/api/services/helloService.ts):
```typescript
import { apiClient } from '../client';

export interface HelloResponse {
  message: string;
  status: string;
  timestamp: string;
}

export async function getHelloMessage(): Promise<HelloResponse> {
  const { data } = await apiClient.get<HelloResponse>('/hello');
  return data;
}
```

[Source: architecture/frontend-architecture.md#api-layer-hooks-services]

### Dashboard Component with API Integration

**Updated Dashboard** (frontend/src/pages/Dashboard.tsx):
```typescript
import { useState, useEffect } from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { getHelloMessage, HelloResponse } from '@/api/services/helloService';

export function Dashboard() {
  const [helloData, setHelloData] = useState<HelloResponse | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchHelloMessage() {
      try {
        const data = await getHelloMessage();
        setHelloData(data);
      } catch (err) {
        console.error('Failed to fetch hello message:', err);
        setError('Failed to connect to backend API');
      } finally {
        setLoading(false);
      }
    }

    fetchHelloMessage();
  }, []);

  if (loading) {
    return <div className="p-6">Loading...</div>;
  }

  if (error) {
    return <div className="p-6 text-destructive">Error: {error}</div>;
  }

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold">{helloData?.message}</h1>
        <p className="text-muted-foreground mt-2">
          Welcome to BMADFlow - Your Documentation Hub for BMAD Method Projects
        </p>
        <p className="text-sm text-muted-foreground mt-1">
          Server timestamp: {helloData?.timestamp}
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Getting Started</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-muted-foreground">
            BMADFlow is a RAG-powered documentation hub that synchronizes GitHub documentation,
            processes it with Docling, indexes it with pgvector, and provides an AI chatbot
            interface for intelligent Q&A.
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
```

[Source: architecture/frontend-architecture.md#pages-route-components]

### Playwright E2E Test

**Installation**:
```bash
cd frontend
npm install -D @playwright/test
npx playwright install
```

**E2E Test** (frontend/tests/e2e/hello-bmadflow.spec.ts):
```typescript
import { test, expect } from '@playwright/test';

test.describe('Hello BMADFlow E2E Integration', () => {
  test('should display Hello BMADFlow message from backend API', async ({ page }) => {
    // Navigate to Dashboard
    await page.goto('http://localhost:3000');

    // Wait for API response to load
    await page.waitForSelector('h1');

    // Verify message from backend API displays
    const heading = await page.locator('h1').textContent();
    expect(heading).toContain('Hello BMADFlow');

    // Verify server timestamp is present (confirms API call succeeded)
    const timestamp = await page.locator('text=Server timestamp:').textContent();
    expect(timestamp).toContain('Server timestamp:');

    // Capture screenshot for validation
    await page.screenshot({ path: 'tests/e2e/screenshots/hello-bmadflow.png', fullPage: true });
  });

  test('should handle API error gracefully', async ({ page }) => {
    // Simulate backend down by navigating before starting backend
    // This test verifies error handling

    // For this test, we'd need to stop backend temporarily
    // Or mock the API to return error
    // For POC, this is optional - focus on happy path
  });
});
```

[Source: architecture/testing-strategy.md#end-to-end-tests-playwright]

**Playwright Config** (frontend/playwright.config.ts):
```typescript
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});
```

**Package.json Script**:
```json
{
  "scripts": {
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  }
}
```

### Playwright MCP Integration

**Purpose**: Playwright MCP enables AI-assisted E2E testing for BMADFlow per FR37-39, FR44.

**MCP Tools Available**:
- `mcp__playwright__browser_navigate`: Programmatically launch frontend
- `mcp__playwright__browser_snapshot`: Capture accessibility snapshot
- `mcp__playwright__browser_take_screenshot`: Capture visual screenshot
- `mcp__playwright__browser_console_messages`: Monitor console errors
- `mcp__playwright__browser_click`: Interact with UI elements

[Source: architecture/testing-strategy.md#playwright-mcp-integration]

**Example Usage**:
```
User: "Test the Dashboard page and capture a screenshot"

Agent workflow:
1. mcp__playwright__browser_navigate("http://localhost:3000")
2. mcp__playwright__browser_snapshot() - Verify page structure
3. mcp__playwright__browser_take_screenshot() - Capture visual proof
4. mcp__playwright__browser_console_messages() - Check for errors
5. Return screenshot and validation results to user
```

### README Documentation

**Quick Start - Full Docker**:
```markdown
## Quick Start - Full Docker

Prerequisites:
- Docker Desktop installed and running
- Ollama running locally with `nomic-embed-text` model

1. Clone repository and navigate to project directory
2. Copy environment file: `cp .env.example .env`
3. Start all services: `docker-compose up`
4. Access frontend: http://localhost:3000
5. Access API docs: http://localhost:8000/docs
6. Access pgAdmin: http://localhost:5050

Verify deployment:
- Backend health: `curl http://localhost:8000/api/health`
- Frontend: Navigate to http://localhost:3000 (should display "Hello BMADFlow")
```

**Quick Start - Hybrid Mode**:
```markdown
## Quick Start - Hybrid Mode

Prerequisites:
- Docker Desktop (for database)
- Python 3.11+
- Node.js 18+
- Ollama running locally

1. Start database: `docker-compose -f docker-compose.hybrid.yml up -d`
2. Start backend:
   ```bash
   cd backend
   python -m venv venv
   source venv/bin/activate  # Windows: venv\Scripts\activate
   pip install -r requirements.txt
   alembic upgrade head
   uvicorn app.main:app --reload --port 8000
   ```
3. Start frontend (new terminal):
   ```bash
   cd frontend
   npm install
   npm run dev
   ```
4. Access frontend: http://localhost:3000
```

[Source: architecture/deployment.md#deployment-steps]

### Epic 1 Validation Checklist

**Full Docker Mode**:
- [ ] `docker-compose up` starts all 4 services (db, backend, frontend, pgadmin)
- [ ] Navigate to http://localhost:3000 displays "Hello BMADFlow" message from API
- [ ] Backend `/api/hello` returns `{"message": "Hello BMADFlow", "status": "ok", "timestamp": "..."}`
- [ ] Backend `/api/health` returns `{"status": "ok", "database": "connected", "timestamp": "..."}`
- [ ] pgAdmin accessible at http://localhost:5050
- [ ] All services healthy: `docker-compose ps`
- [ ] Hot reload works (edit backend/frontend code, see auto-reload)

**Database Validation**:
- [ ] PostgreSQL container running and accessible
- [ ] pgvector extension enabled: `docker exec bmadflow-db psql -U bmadflow -d bmadflow -c "SELECT * FROM pg_extension WHERE extname = 'vector';"`
- [ ] Database persists data across container restarts

**Testing Validation**:
- [ ] E2E test passes: `cd frontend && npm run test:e2e`
- [ ] Screenshot captured: `tests/e2e/screenshots/hello-bmadflow.png`
- [ ] Backend health check returns 200 OK

[Source: architecture/deployment.md#definition-of-done]

### Testing

#### Testing Standards

**E2E Testing** (Playwright):
- Test full-stack integration: frontend → backend → database
- Verify "Hello BMADFlow" message displays from API
- Capture screenshot for validation
- Test passes successfully on local environment

**Integration Testing**:
- Test backend `/api/hello` endpoint returns correct JSON
- Test frontend API client fetches and displays data
- Test error handling when backend unavailable

**Manual Testing**:
```bash
# Full Docker Mode
docker-compose up

# Access frontend
open http://localhost:3000
# Verify: "Hello BMADFlow" message displays with server timestamp

# Test backend endpoints
curl http://localhost:8000/api/health
curl http://localhost:8000/api/hello

# View OpenAPI docs
open http://localhost:8000/docs

# Run E2E test
cd frontend
npm run test:e2e

# View test report
npx playwright show-report
```

[Source: architecture/testing-strategy.md#end-to-end-tests-playwright]

**Success Criteria**:
- E2E test passes validating full stack
- "Hello BMADFlow" message displays in browser
- Backend API responds successfully
- Database connection verified
- All Epic 1 acceptance criteria met

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-06 | 1.0 | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent_
