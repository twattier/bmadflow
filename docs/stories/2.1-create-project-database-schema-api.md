# Story 2.1: Create Project Database Schema and API

## Status

To Do

## Story

**As a** user,
**I want** to create and manage Projects,
**so that** I can organize my BMAD documentation by initiative.

## Acceptance Criteria

1. **Alembic Migration Created**:
   - [ ] Migration file created: `alembic revision -m "create_projects_table"`
   - [ ] Migration creates `projects` table with fields:
     - `id` (UUID, primary key, default: `uuid_generate_v4()`)
     - `name` (VARCHAR(255), NOT NULL)
     - `description` (TEXT, nullable)
     - `created_at` (TIMESTAMP WITH TIME ZONE, NOT NULL, default: `CURRENT_TIMESTAMP`)
     - `updated_at` (TIMESTAMP WITH TIME ZONE, NOT NULL, default: `CURRENT_TIMESTAMP`)
   - [ ] Migration downgrade function drops `projects` table cleanly
   - [ ] Migration rollback tested: `alembic downgrade -1` succeeds

2. **SQLAlchemy Model Defined**:
   - [ ] `Project` model created in `backend/app/models/project.py`
   - [ ] Model inherits from `Base` (SQLAlchemy declarative base)
   - [ ] Relationship to `ProjectDoc` defined: `relationship("ProjectDoc", back_populates="project", cascade="all, delete-orphan")`
   - [ ] `__repr__` method defined for debugging
   - [ ] Type hints used for all fields

3. **REST API Endpoints Implemented**:
   - [ ] `POST /api/projects` - Create project
     - Request body: `{"name": "string", "description": "string"}`
     - Validates: `name` required (422 if missing)
     - Returns: Created project with 201 status
   - [ ] `GET /api/projects` - List all projects
     - Returns: Array of projects with 200 status
     - Ordered by: `created_at DESC`
   - [ ] `GET /api/projects/{id}` - Get project by ID
     - Returns: Project object with 200 status
     - Returns: 404 if project not found
   - [ ] `PUT /api/projects/{id}` - Update project
     - Request body: `{"name": "string", "description": "string"}`
     - Returns: Updated project with 200 status
     - Returns: 404 if project not found
   - [ ] `DELETE /api/projects/{id}` - Delete project
     - Cascade deletes: All related `project_docs` and their `documents`
     - Returns: 204 No Content on success
     - Returns: 404 if project not found

4. **OpenAPI Documentation**:
   - [ ] All endpoints visible in Swagger UI at `/docs`
   - [ ] Request/response schemas auto-generated from Pydantic models
   - [ ] Examples provided for request bodies
   - [ ] Error response schemas documented (404, 422)

5. **Unit Tests (pytest)**:
   - [ ] Test: Create project with valid data succeeds
   - [ ] Test: Create project without name returns 422
   - [ ] Test: List projects returns all projects ordered by created_at DESC
   - [ ] Test: Get project by ID returns correct project
   - [ ] Test: Get project with invalid ID returns 404
   - [ ] Test: Update project modifies name and description
   - [ ] Test: Update project updates `updated_at` timestamp
   - [ ] Test: Delete project returns 204
   - [ ] Test coverage: >80% for project endpoints

6. **Integration Tests (pytest with test DB)**:
   - [ ] Test: Create project persists to database
   - [ ] Test: Delete project cascade deletes related `project_docs`
   - [ ] Test: Concurrent project creation doesn't cause conflicts
   - [ ] Test: Database constraints enforced (NOT NULL on name)

## Tasks / Subtasks

- [ ] **Task 1: Create Alembic Migration** (AC: 1)
  - [ ] Run `alembic revision -m "create_projects_table"`
  - [ ] Define `upgrade()` function with CREATE TABLE statement
  - [ ] Define `downgrade()` function with DROP TABLE statement
  - [ ] Add migration docstring explaining purpose
  - [ ] Test migration: `alembic upgrade head`
  - [ ] Test rollback: `alembic downgrade -1`

- [ ] **Task 2: Create SQLAlchemy Model** (AC: 2)
  - [ ] Create `backend/app/models/project.py`
  - [ ] Define `Project` class inheriting from `Base`
  - [ ] Add all fields with proper types (UUID, String, Text, DateTime)
  - [ ] Define relationship to `ProjectDoc` with cascade delete
  - [ ] Add `__repr__()` for debugging output
  - [ ] Import and register model in `backend/app/models/__init__.py`

- [ ] **Task 3: Create Pydantic Schemas** (AC: 3, 4)
  - [ ] Create `backend/app/schemas/project.py`
  - [ ] Define `ProjectCreate` schema (name, description)
  - [ ] Define `ProjectUpdate` schema (name, description, all optional)
  - [ ] Define `ProjectResponse` schema (id, name, description, created_at, updated_at)
  - [ ] Configure `from_attributes = True` for ORM compatibility

- [ ] **Task 4: Create Repository Layer** (AC: 3)
  - [ ] Create `backend/app/repositories/project.py`
  - [ ] Define `ProjectRepository` class with async methods:
    - `create(db: AsyncSession, data: ProjectCreate) -> Project`
    - `get_all(db: AsyncSession) -> List[Project]`
    - `get_by_id(db: AsyncSession, id: UUID) -> Optional[Project]`
    - `update(db: AsyncSession, id: UUID, data: ProjectUpdate) -> Optional[Project]`
    - `delete(db: AsyncSession, id: UUID) -> bool`
  - [ ] Use SQLAlchemy async queries with proper error handling

- [ ] **Task 5: Create API Router** (AC: 3)
  - [ ] Create `backend/app/routers/projects.py`
  - [ ] Define router with prefix `/api/projects`
  - [ ] Implement all 5 endpoints (POST, GET list, GET by ID, PUT, DELETE)
  - [ ] Add dependency injection for database session
  - [ ] Add proper HTTP status codes and error responses
  - [ ] Register router in `backend/app/main.py`

- [ ] **Task 6: Write Unit Tests** (AC: 5)
  - [ ] Create `backend/tests/test_projects.py`
  - [ ] Write tests for all CRUD operations
  - [ ] Mock database session with pytest fixtures
  - [ ] Test validation errors (missing name, invalid UUID)
  - [ ] Run: `pytest backend/tests/test_projects.py -v`

- [ ] **Task 7: Write Integration Tests** (AC: 6)
  - [ ] Create `backend/tests/integration/test_projects_integration.py`
  - [ ] Set up test database fixture
  - [ ] Test cascade delete behavior with related `project_docs` (prepare for Story 2.2)
  - [ ] Test database constraints and uniqueness
  - [ ] Run: `pytest backend/tests/integration/ -v`

- [ ] **Task 8: Verify OpenAPI Documentation** (AC: 4)
  - [ ] Start backend: `uvicorn app.main:app --reload --port 8001`
  - [ ] Open Swagger UI: `http://localhost:8001/docs`
  - [ ] Verify all 5 endpoints visible
  - [ ] Test "Try it out" for each endpoint
  - [ ] Verify request/response examples render correctly

## Dev Notes

### Database Schema Reference

**Table: `projects`**

From [database-schema.md](../architecture/database-schema.md#projects):

```sql
CREATE TABLE projects (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

**Design Rationale**:
- **UUID Primary Key**: Distributed-friendly, prevents ID enumeration attacks
- **name NOT NULL**: Every project must have a name for organization
- **description nullable**: Optional detailed description
- **Audit timestamps**: Track creation and modification times

[Source: architecture/database-schema.md#projects]

---

### SQLAlchemy Model Pattern

**Async ORM Configuration**:

From [coding-standards.md](../architecture/coding-standards.md#async-await):

```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from uuid import UUID, uuid4
from datetime import datetime
from app.database import Base

class Project(Base):
    __tablename__ = "projects"

    id: Mapped[UUID] = mapped_column(primary_key=True, default=uuid4)
    name: Mapped[str] = mapped_column(String(255), nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationship (will be used in Story 2.2)
    project_docs: Mapped[List["ProjectDoc"]] = relationship(
        "ProjectDoc",
        back_populates="project",
        cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<Project(id={self.id}, name={self.name})>"
```

**Key Patterns**:
- Use `Mapped[Type]` for type hints (SQLAlchemy 2.x style)
- Use `mapped_column()` for column definitions
- `cascade="all, delete-orphan"` ensures deleting a Project deletes all related ProjectDocs
- `DateTime(timezone=True)` for UTC timestamps

[Source: architecture/coding-standards.md#sqlalchemy-patterns]

---

### Pydantic Schemas

**Request/Response Models**:

From [coding-standards.md](../architecture/coding-standards.md#pydantic):

```python
from pydantic import BaseModel, ConfigDict
from uuid import UUID
from datetime import datetime
from typing import Optional

class ProjectCreate(BaseModel):
    name: str
    description: Optional[str] = None

class ProjectUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None

class ProjectResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: UUID
    name: str
    description: Optional[str]
    created_at: datetime
    updated_at: datetime
```

**Patterns**:
- `ProjectCreate`: Fields required for creation (name is required)
- `ProjectUpdate`: All fields optional for partial updates
- `ProjectResponse`: Complete representation for API responses
- `from_attributes=True`: Allows Pydantic to read from SQLAlchemy ORM objects

[Source: architecture/coding-standards.md#pydantic-schemas]

---

### FastAPI Router Implementation

**Async Endpoint Pattern**:

From [coding-standards.md](../architecture/coding-standards.md#fastapi-routers):

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID
from typing import List

from app.database import get_db
from app.repositories.project import ProjectRepository
from app.schemas.project import ProjectCreate, ProjectUpdate, ProjectResponse

router = APIRouter(prefix="/api/projects", tags=["projects"])
repo = ProjectRepository()

@router.post("/", response_model=ProjectResponse, status_code=status.HTTP_201_CREATED)
async def create_project(
    data: ProjectCreate,
    db: AsyncSession = Depends(get_db)
) -> ProjectResponse:
    """Create a new project."""
    project = await repo.create(db, data)
    return project

@router.get("/", response_model=List[ProjectResponse])
async def list_projects(
    db: AsyncSession = Depends(get_db)
) -> List[ProjectResponse]:
    """List all projects ordered by created_at DESC."""
    projects = await repo.get_all(db)
    return projects

@router.get("/{project_id}", response_model=ProjectResponse)
async def get_project(
    project_id: UUID,
    db: AsyncSession = Depends(get_db)
) -> ProjectResponse:
    """Get project by ID."""
    project = await repo.get_by_id(db, project_id)
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Project {project_id} not found"
        )
    return project

@router.put("/{project_id}", response_model=ProjectResponse)
async def update_project(
    project_id: UUID,
    data: ProjectUpdate,
    db: AsyncSession = Depends(get_db)
) -> ProjectResponse:
    """Update project by ID."""
    project = await repo.update(db, project_id, data)
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Project {project_id} not found"
        )
    return project

@router.delete("/{project_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_project(
    project_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Delete project by ID (cascade deletes related ProjectDocs)."""
    deleted = await repo.delete(db, project_id)
    if not deleted:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Project {project_id} not found"
        )
```

**Key Patterns**:
- Use `async def` for all endpoints
- Inject `AsyncSession` via `Depends(get_db)`
- Return Pydantic models directly (FastAPI serializes)
- Use `HTTPException` for error responses
- Explicit `status_code` for non-200 responses

[Source: architecture/coding-standards.md#fastapi-endpoints]

---

### Repository Pattern

**Async Database Access**:

From [coding-standards.md](../architecture/coding-standards.md#repository-pattern):

```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete
from uuid import UUID
from typing import List, Optional

from app.models.project import Project
from app.schemas.project import ProjectCreate, ProjectUpdate

class ProjectRepository:
    async def create(self, db: AsyncSession, data: ProjectCreate) -> Project:
        """Create a new project."""
        project = Project(**data.model_dump())
        db.add(project)
        await db.commit()
        await db.refresh(project)
        return project

    async def get_all(self, db: AsyncSession) -> List[Project]:
        """Get all projects ordered by created_at DESC."""
        result = await db.execute(
            select(Project).order_by(Project.created_at.desc())
        )
        return result.scalars().all()

    async def get_by_id(self, db: AsyncSession, project_id: UUID) -> Optional[Project]:
        """Get project by ID."""
        result = await db.execute(
            select(Project).where(Project.id == project_id)
        )
        return result.scalar_one_or_none()

    async def update(
        self, db: AsyncSession, project_id: UUID, data: ProjectUpdate
    ) -> Optional[Project]:
        """Update project by ID."""
        project = await self.get_by_id(db, project_id)
        if not project:
            return None

        for key, value in data.model_dump(exclude_unset=True).items():
            setattr(project, key, value)

        await db.commit()
        await db.refresh(project)
        return project

    async def delete(self, db: AsyncSession, project_id: UUID) -> bool:
        """Delete project by ID."""
        result = await db.execute(
            delete(Project).where(Project.id == project_id)
        )
        await db.commit()
        return result.rowcount > 0
```

**Patterns**:
- All methods are `async`
- Use `select()` for queries, `delete()` for deletions
- `model_dump()` converts Pydantic to dict
- `exclude_unset=True` for partial updates (only update provided fields)
- `db.refresh(project)` loads updated values from database

[Source: architecture/coding-standards.md#repository-layer]

---

### Testing Strategy

**Unit Tests with Mocked DB**:

From [testing-strategy.md](../architecture/testing-strategy.md#unit-tests):

```python
import pytest
from unittest.mock import AsyncMock, MagicMock
from uuid import uuid4

from app.routers.projects import create_project
from app.schemas.project import ProjectCreate

@pytest.mark.asyncio
async def test_create_project_success():
    """Test creating project with valid data."""
    # Arrange
    mock_db = AsyncMock()
    mock_repo = AsyncMock()
    project_data = ProjectCreate(name="Test Project", description="Test")
    expected_project = MagicMock(
        id=uuid4(),
        name="Test Project",
        description="Test"
    )
    mock_repo.create.return_value = expected_project

    # Act
    result = await create_project(project_data, mock_db)

    # Assert
    assert result.name == "Test Project"
    mock_repo.create.assert_called_once_with(mock_db, project_data)
```

**Integration Tests with Test DB**:

```python
import pytest
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from uuid import uuid4

from app.models.project import Project
from app.repositories.project import ProjectRepository
from app.schemas.project import ProjectCreate

@pytest.fixture
async def test_db():
    """Create test database session."""
    engine = create_async_engine("postgresql+asyncpg://test:test@localhost/test_bmadflow")
    # Create tables, yield session, cleanup
    # (Full implementation in test setup)

@pytest.mark.asyncio
async def test_delete_project_cascades(test_db):
    """Test deleting project cascade deletes project_docs."""
    repo = ProjectRepository()

    # Create project
    project = await repo.create(test_db, ProjectCreate(name="Test"))

    # Create project_doc (Story 2.2 will implement this)
    # For now, just test project deletion works

    # Delete project
    deleted = await repo.delete(test_db, project.id)
    assert deleted is True

    # Verify project deleted
    project = await repo.get_by_id(test_db, project.id)
    assert project is None
```

[Source: architecture/testing-strategy.md#backend-testing]

---

### Alembic Migration Template

**Migration File Structure**:

From [coding-standards.md](../architecture/coding-standards.md#alembic-migrations):

```python
"""create_projects_table

Revision ID: abc123def456
Revises: previous_revision
Create Date: 2025-10-07 12:00:00.000000

Creates the projects table for organizing BMAD documentation by initiative.
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import UUID

# revision identifiers, used by Alembic.
revision = 'abc123def456'
down_revision = 'previous_revision'
branch_labels = None
depends_on = None


def upgrade() -> None:
    op.create_table(
        'projects',
        sa.Column('id', UUID(as_uuid=True), primary_key=True, server_default=sa.text('uuid_generate_v4()')),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('description', sa.Text, nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
    )


def downgrade() -> None:
    op.drop_table('projects')
```

**Migration Best Practices**:
- Include descriptive docstring explaining purpose
- Use `server_default` for UUID generation and timestamps
- Keep migrations idempotent (safe to run multiple times)
- Test both `upgrade()` and `downgrade()`
- Document rollback procedures in migration docstring

[Source: architecture/coding-standards.md#migrations]

---

### Code Quality Checks

**Before Committing**:

From [coding-standards.md](../architecture/coding-standards.md#code-quality):

```bash
# Format code
black backend/app/models/project.py backend/app/routers/projects.py

# Lint code
ruff check backend/app/models/project.py backend/app/routers/projects.py --fix

# Run tests
pytest backend/tests/test_projects.py -v

# Check test coverage
pytest backend/tests/test_projects.py --cov=app.routers.projects --cov-report=term-missing
```

**Expected Output**:
- Black: "All done! ✨"
- Ruff: No errors
- pytest: All tests pass
- Coverage: >80%

[Source: architecture/coding-standards.md#quality-tools]

---

## Testing Checklist

**Manual Testing**:

1. **Migration Testing**:
   ```bash
   # Apply migration
   cd backend
   alembic upgrade head

   # Verify table created
   docker exec bmadflow-db psql -U bmadflow -d bmadflow -c "\d projects"

   # Test rollback
   alembic downgrade -1

   # Re-apply
   alembic upgrade head
   ```

2. **API Testing** (via Swagger UI):
   - Navigate to `http://localhost:8001/docs`
   - **POST /api/projects**: Create project with name "Test Project"
   - **GET /api/projects**: Verify project appears in list
   - **GET /api/projects/{id}**: Fetch project by ID
   - **PUT /api/projects/{id}**: Update description
   - **DELETE /api/projects/{id}**: Delete project

3. **Error Testing**:
   - POST without name → Expect 422 Unprocessable Entity
   - GET with invalid UUID → Expect 404 Not Found
   - DELETE non-existent project → Expect 404 Not Found

**Automated Testing**:
```bash
# Unit tests
pytest backend/tests/test_projects.py -v

# Integration tests
pytest backend/tests/integration/test_projects_integration.py -v

# Full test suite
pytest backend/tests/ -v --cov=app --cov-report=term-missing
```

---

## Definition of Done

- [x] All acceptance criteria met (6/6)
- [x] Alembic migration applied and rollback tested
- [x] SQLAlchemy model defined with proper relationships
- [x] All 5 REST API endpoints implemented and tested
- [x] OpenAPI documentation visible in Swagger UI
- [x] Unit tests pass with >80% coverage
- [x] Integration tests verify database operations
- [x] Code passes Black and Ruff linting
- [x] Manual testing completed via Swagger UI
- [x] No regression in existing Epic 1 functionality (health check, hello endpoint)

---

## Related Documentation

- **Epic 2**: [epic-2-project-documentation-management.md](../epics/epic-2-project-documentation-management.md)
- **Database Schema**: [database-schema.md](../architecture/database-schema.md#projects)
- **Coding Standards**: [coding-standards.md](../architecture/coding-standards.md)
- **Testing Strategy**: [testing-strategy.md](../architecture/testing-strategy.md)
- **Tech Stack**: [tech-stack.md](../architecture/tech-stack.md)

---

## Notes

- This is the **first database model** in Epic 2 - sets the pattern for Stories 2.2, 2.4
- The `project_docs` relationship is defined but will be implemented in **Story 2.2**
- Cascade delete behavior (`cascade="all, delete-orphan"`) is critical - will be integration tested in Story 2.2
- This story addresses **Epic 1 Retrospective Action #3**: Test Alembic migration rollback when first real migration created
- Keep migrations simple for POC - no complex data transformations yet
