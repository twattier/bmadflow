# Story 2.2: Create ProjectDoc Database Schema and API

## Status

Done

## Story

**As a** user,
**I want** to configure ProjectDocs linked to GitHub repositories,
**so that** I can sync documentation from specific repos into my Projects.

## Acceptance Criteria

1. **Alembic Migration Created**:
   - [ ] Migration file created: `alembic revision -m "create_project_docs_table"`
   - [ ] Migration creates `project_docs` table with fields:
     - `id` (UUID, primary key, default: `uuid_generate_v4()`)
     - `project_id` (UUID, FOREIGN KEY → projects(id) ON DELETE CASCADE, NOT NULL)
     - `name` (VARCHAR(255), NOT NULL)
     - `description` (TEXT, nullable)
     - `github_url` (VARCHAR(512), NOT NULL)
     - `github_folder_path` (VARCHAR(512), nullable)
     - `last_synced_at` (TIMESTAMP WITH TIME ZONE, nullable)
     - `last_github_commit_date` (TIMESTAMP WITH TIME ZONE, nullable)
     - `created_at` (TIMESTAMP WITH TIME ZONE, NOT NULL, default: `CURRENT_TIMESTAMP`)
     - `updated_at` (TIMESTAMP WITH TIME ZONE, NOT NULL, default: `CURRENT_TIMESTAMP`)
   - [ ] Foreign key constraint on `project_id` with CASCADE delete
   - [ ] Migration downgrade function drops `project_docs` table cleanly
   - [ ] Migration rollback tested: `alembic downgrade -1` succeeds

2. **SQLAlchemy Model Defined**:
   - [ ] `ProjectDoc` model created in `backend/app/models/project_doc.py`
   - [ ] Model inherits from `Base` (SQLAlchemy declarative base)
   - [ ] Relationship to `Project` defined: `relationship("Project", back_populates="project_docs")`
   - [ ] Relationship to `Document` prepared: `relationship("Document", back_populates="project_doc", cascade="all, delete-orphan")` (commented out until Story 2.4)
   - [ ] `__repr__` method defined for debugging
   - [ ] Type hints used for all fields
   - [ ] GitHub URL validation logic: Pydantic validator ensures valid GitHub repo URL format

3. **REST API Endpoints Implemented**:
   - [ ] `POST /api/projects/{project_id}/docs` - Create ProjectDoc
     - Request body: `{"name": "string", "description": "string", "github_url": "https://github.com/user/repo", "github_folder_path": "docs"}`
     - Validates: `name` required, `github_url` required and valid GitHub URL format (422 if invalid)
     - Returns: Created ProjectDoc with 201 status
   - [ ] `GET /api/projects/{project_id}/docs` - List ProjectDocs for a Project
     - Returns: Array of ProjectDocs with 200 status
     - Ordered by: `created_at DESC`
   - [ ] `GET /api/project-docs/{id}` - Get ProjectDoc by ID
     - Returns: ProjectDoc object with 200 status
     - Returns: 404 if ProjectDoc not found
   - [ ] `PUT /api/project-docs/{id}` - Update ProjectDoc
     - Request body: `{"name": "string", "description": "string", "github_url": "string", "github_folder_path": "string"}`
     - Returns: Updated ProjectDoc with 200 status
     - Returns: 404 if ProjectDoc not found
   - [ ] `DELETE /api/project-docs/{id}` - Delete ProjectDoc
     - Cascade deletes: All related `documents` (when Story 2.4 implemented)
     - Returns: 204 No Content on success
     - Returns: 404 if ProjectDoc not found

4. **OpenAPI Documentation**:
   - [ ] All endpoints visible in Swagger UI at `/docs`
   - [ ] Request/response schemas auto-generated from Pydantic models
   - [ ] Examples provided for request bodies
   - [ ] Error response schemas documented (404, 422)

5. **Unit Tests (pytest)**:
   - [ ] Test: Create ProjectDoc with valid data succeeds
   - [ ] Test: Create ProjectDoc without name returns 422
   - [ ] Test: Create ProjectDoc with invalid GitHub URL returns 422
   - [ ] Test: List ProjectDocs returns all ProjectDocs for a project ordered by created_at DESC
   - [ ] Test: Get ProjectDoc by ID returns correct ProjectDoc
   - [ ] Test: Get ProjectDoc with invalid ID returns 404
   - [ ] Test: Update ProjectDoc modifies fields and updates `updated_at` timestamp
   - [ ] Test: Delete ProjectDoc returns 204
   - [ ] Test coverage: >80% for ProjectDoc endpoints

6. **Integration Tests (pytest with test DB)**:
   - [ ] Test: Create ProjectDoc persists to database
   - [ ] Test: Delete ProjectDoc succeeds
   - [ ] Test: Delete Project cascade deletes related `project_docs`
   - [ ] Test: GitHub URL validation enforced (invalid URLs rejected)
   - [ ] Test: Foreign key constraint enforced (cannot create ProjectDoc for non-existent Project)

## Tasks / Subtasks

- [x] **Task 1: Create Alembic Migration** (AC: 1)
  - [x] Run `alembic revision -m "create_project_docs_table"`
  - [x] Define `upgrade()` function with CREATE TABLE statement
  - [x] Add foreign key constraint: `project_id` → `projects.id` ON DELETE CASCADE
  - [x] Define `downgrade()` function with DROP TABLE statement
  - [x] Add migration docstring explaining purpose
  - [x] Test migration: `alembic upgrade head`
  - [x] Test rollback: `alembic downgrade -1`

- [x] **Task 2: Create SQLAlchemy Model** (AC: 2)
  - [x] Create `backend/app/models/project_doc.py`
  - [x] Define `ProjectDoc` class inheriting from `Base`
  - [x] Add all fields with proper types (UUID, String, Text, DateTime)
  - [x] Define relationship to `Project` with back_populates
  - [x] Define relationship to `Document` with cascade delete (commented out until Story 2.4)
  - [x] Add `__repr__()` for debugging output
  - [x] Import and register model in `backend/app/models/__init__.py`

- [x] **Task 3: Create Pydantic Schemas** (AC: 3, 4)
  - [x] Create `backend/app/schemas/project_doc.py`
  - [x] Define `ProjectDocCreate` schema (name, description, github_url, github_folder_path)
  - [x] Define `ProjectDocUpdate` schema (all fields optional)
  - [x] Define `ProjectDocResponse` schema (all fields including id, timestamps, sync fields)
  - [x] Configure `from_attributes = True` for ORM compatibility
  - [x] Add Pydantic field validator for `github_url` to validate GitHub URL format

- [x] **Task 4: Create Repository Layer** (AC: 3)
  - [x] Create `backend/app/repositories/project_doc.py`
  - [x] Define `ProjectDocRepository` class with async methods:
    - `create(db: AsyncSession, project_id: UUID, data: ProjectDocCreate) -> ProjectDoc`
    - `get_all_by_project(db: AsyncSession, project_id: UUID) -> List[ProjectDoc]`
    - `get_by_id(db: AsyncSession, id: UUID) -> Optional[ProjectDoc]`
    - `update(db: AsyncSession, id: UUID, data: ProjectDocUpdate) -> Optional[ProjectDoc]`
    - `delete(db: AsyncSession, id: UUID) -> bool`
  - [x] Use SQLAlchemy async queries with proper error handling

- [x] **Task 5: Create API Router** (AC: 3)
  - [x] Create `backend/app/routers/project_docs.py`
  - [x] Define router with prefix `/api`
  - [x] Implement all 5 endpoints (POST, GET list, GET by ID, PUT, DELETE)
  - [x] Add dependency injection for database session
  - [x] Add proper HTTP status codes and error responses
  - [x] Register router in `backend/app/main.py`

- [x] **Task 6: Write Unit Tests** (AC: 5)
  - [x] Create `backend/tests/test_project_docs.py`
  - [x] Write tests for all CRUD operations
  - [x] Mock database session with pytest fixtures
  - [x] Test validation errors (missing name, invalid GitHub URL, invalid UUID)
  - [x] Run: `pytest backend/tests/test_project_docs.py -v`

- [x] **Task 7: Write Integration Tests** (AC: 6)
  - [x] Create `backend/tests/integration/test_project_docs_integration.py`
  - [x] Set up test database fixture
  - [x] Test cascade delete behavior (Project → ProjectDocs)
  - [x] Test foreign key constraint (create ProjectDoc for non-existent Project fails)
  - [x] Test GitHub URL validation at database level
  - [x] Run: `pytest backend/tests/integration/ -v`

- [x] **Task 8: Verify OpenAPI Documentation** (AC: 4)
  - [x] Start backend: `uvicorn app.main:app --reload --port 8001`
  - [x] Open Swagger UI: `http://localhost:8001/docs`
  - [x] Verify all 5 endpoints visible
  - [x] Test "Try it out" for each endpoint
  - [x] Verify request/response examples render correctly

## Dev Notes

### Database Schema Reference

**Table: `project_docs`**

From [database-schema.md](../architecture/database-schema.md#project_docs):

```sql
CREATE TABLE project_docs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    github_url VARCHAR(512) NOT NULL,
    github_folder_path VARCHAR(512),
    last_synced_at TIMESTAMP WITH TIME ZONE,
    last_github_commit_date TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

**Design Rationale**:
- **UUID Primary Key**: Distributed-friendly, prevents ID enumeration attacks
- **project_id FK with CASCADE**: Deleting a Project automatically deletes all its ProjectDocs
- **github_url NOT NULL**: Every ProjectDoc must have a GitHub repository URL
- **github_folder_path nullable**: NULL means sync from repository root
- **Sync timestamps nullable**: NULL until first sync completes
- **Audit timestamps**: Track creation and modification times

[Source: architecture/database-schema.md#project_docs]

---

### SQLAlchemy Model Pattern

**Async ORM Configuration**:

From [data-models.md](../architecture/data-models.md#projectdoc-model):

```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import String, Text, ForeignKey, DateTime, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from uuid import UUID
from datetime import datetime
from typing import Optional, List
from app.database import Base

class ProjectDoc(Base):
    __tablename__ = "project_docs"

    id: Mapped[UUID] = mapped_column(primary_key=True, default=uuid.uuid4)
    project_id: Mapped[UUID] = mapped_column(
        ForeignKey("projects.id", ondelete="CASCADE"),
        nullable=False
    )

    name: Mapped[str] = mapped_column(String(255), nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    github_url: Mapped[str] = mapped_column(String(512), nullable=False)
    github_folder_path: Mapped[Optional[str]] = mapped_column(String(512), nullable=True)

    last_synced_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )
    last_github_commit_date: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now()
    )

    # Relationships
    project: Mapped["Project"] = relationship(back_populates="project_docs")

    # Relationship to Document (Story 2.4 - comment out for now)
    # documents: Mapped[List["Document"]] = relationship(
    #     "Document",
    #     back_populates="project_doc",
    #     cascade="all, delete-orphan"
    # )

    def __repr__(self) -> str:
        return f"<ProjectDoc(id={self.id}, name={self.name}, project_id={self.project_id})>"
```

**Key Patterns**:
- Use `Mapped[Type]` for type hints (SQLAlchemy 2.x style)
- Use `mapped_column()` for column definitions
- `ForeignKey("projects.id", ondelete="CASCADE")` ensures deleting a Project deletes all ProjectDocs
- `DateTime(timezone=True)` for UTC timestamps
- Sync timestamps (`last_synced_at`, `last_github_commit_date`) are nullable (NULL until Story 2.5 implements sync)

[Source: architecture/data-models.md#projectdoc-model]

---

### Pydantic Schemas

**Request/Response Models**:

From [data-models.md](../architecture/data-models.md#pydantic-models):

```python
from pydantic import BaseModel, ConfigDict, Field, HttpUrl, field_validator
from uuid import UUID
from datetime import datetime
from typing import Optional

class ProjectDocCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    github_url: HttpUrl  # Pydantic validates URL format
    github_folder_path: Optional[str] = None

    @field_validator('github_url')
    @classmethod
    def validate_github_url(cls, v: HttpUrl) -> HttpUrl:
        """Ensure URL is from github.com."""
        if v.host not in ['github.com', 'www.github.com']:
            raise ValueError('Must be a GitHub repository URL')
        return v

    @field_validator('github_folder_path')
    @classmethod
    def validate_folder_path(cls, v: Optional[str]) -> Optional[str]:
        """Normalize folder path (remove leading/trailing slashes)."""
        if v is None:
            return v
        return v.strip('/')

class ProjectDocUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    description: Optional[str] = None
    github_url: Optional[HttpUrl] = None
    github_folder_path: Optional[str] = None

class ProjectDocResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: UUID
    project_id: UUID
    name: str
    description: Optional[str]
    github_url: str
    github_folder_path: Optional[str]
    last_synced_at: Optional[datetime]
    last_github_commit_date: Optional[datetime]
    created_at: datetime
    updated_at: datetime
```

**Patterns**:
- `ProjectDocCreate`: Fields required for creation (name, github_url required)
- `ProjectDocUpdate`: All fields optional for partial updates
- `ProjectDocResponse`: Complete representation for API responses
- `from_attributes=True`: Allows Pydantic to read from SQLAlchemy ORM objects
- `HttpUrl` type: Automatically validates URL format
- Custom validators: `validate_github_url` ensures only GitHub URLs accepted

[Source: architecture/data-models.md#pydantic-models]

---

### FastAPI Router Implementation

**Async Endpoint Pattern**:

From [api-specification.md](../architecture/api-specification.md#project-docs-api) and [coding-standards.md](../architecture/coding-standards.md#fastapi-routers):

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID
from typing import List

from app.database import get_db
from app.repositories.project_doc import ProjectDocRepository
from app.schemas.project_doc import ProjectDocCreate, ProjectDocUpdate, ProjectDocResponse

router = APIRouter(prefix="/api", tags=["project-docs"])
repo = ProjectDocRepository()

@router.post("/projects/{project_id}/docs", response_model=ProjectDocResponse, status_code=status.HTTP_201_CREATED)
async def create_project_doc(
    project_id: UUID,
    data: ProjectDocCreate,
    db: AsyncSession = Depends(get_db)
) -> ProjectDocResponse:
    """Create a new ProjectDoc for a Project."""
    project_doc = await repo.create(db, project_id, data)
    return project_doc

@router.get("/projects/{project_id}/docs", response_model=List[ProjectDocResponse])
async def list_project_docs(
    project_id: UUID,
    db: AsyncSession = Depends(get_db)
) -> List[ProjectDocResponse]:
    """List all ProjectDocs for a Project ordered by created_at DESC."""
    project_docs = await repo.get_all_by_project(db, project_id)
    return project_docs

@router.get("/project-docs/{id}", response_model=ProjectDocResponse)
async def get_project_doc(
    id: UUID,
    db: AsyncSession = Depends(get_db)
) -> ProjectDocResponse:
    """Get ProjectDoc by ID."""
    project_doc = await repo.get_by_id(db, id)
    if not project_doc:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"ProjectDoc {id} not found"
        )
    return project_doc

@router.put("/project-docs/{id}", response_model=ProjectDocResponse)
async def update_project_doc(
    id: UUID,
    data: ProjectDocUpdate,
    db: AsyncSession = Depends(get_db)
) -> ProjectDocResponse:
    """Update ProjectDoc by ID."""
    project_doc = await repo.update(db, id, data)
    if not project_doc:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"ProjectDoc {id} not found"
        )
    return project_doc

@router.delete("/project-docs/{id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_project_doc(
    id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Delete ProjectDoc by ID (cascade deletes related Documents)."""
    deleted = await repo.delete(db, id)
    if not deleted:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"ProjectDoc {id} not found"
        )
```

**Key Patterns**:
- Use `async def` for all endpoints
- Inject `AsyncSession` via `Depends(get_db)`
- Return Pydantic models directly (FastAPI serializes)
- Use `HTTPException` for error responses
- Explicit `status_code` for non-200 responses
- `POST /projects/{project_id}/docs` for nested resource creation
- `GET /project-docs/{id}` for direct resource access

[Source: architecture/api-specification.md#project-docs-api]

---

### Repository Pattern

**Async Database Access**:

From [coding-standards.md](../architecture/coding-standards.md#repository-pattern):

```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete
from uuid import UUID
from typing import List, Optional

from app.models.project_doc import ProjectDoc
from app.schemas.project_doc import ProjectDocCreate, ProjectDocUpdate

class ProjectDocRepository:
    async def create(self, db: AsyncSession, project_id: UUID, data: ProjectDocCreate) -> ProjectDoc:
        """Create a new ProjectDoc."""
        project_doc = ProjectDoc(
            project_id=project_id,
            **data.model_dump()
        )
        db.add(project_doc)
        await db.commit()
        await db.refresh(project_doc)
        return project_doc

    async def get_all_by_project(self, db: AsyncSession, project_id: UUID) -> List[ProjectDoc]:
        """Get all ProjectDocs for a Project ordered by created_at DESC."""
        result = await db.execute(
            select(ProjectDoc)
            .where(ProjectDoc.project_id == project_id)
            .order_by(ProjectDoc.created_at.desc())
        )
        return result.scalars().all()

    async def get_by_id(self, db: AsyncSession, id: UUID) -> Optional[ProjectDoc]:
        """Get ProjectDoc by ID."""
        result = await db.execute(
            select(ProjectDoc).where(ProjectDoc.id == id)
        )
        return result.scalar_one_or_none()

    async def update(
        self, db: AsyncSession, id: UUID, data: ProjectDocUpdate
    ) -> Optional[ProjectDoc]:
        """Update ProjectDoc by ID."""
        project_doc = await self.get_by_id(db, id)
        if not project_doc:
            return None

        for key, value in data.model_dump(exclude_unset=True).items():
            setattr(project_doc, key, value)

        await db.commit()
        await db.refresh(project_doc)
        return project_doc

    async def delete(self, db: AsyncSession, id: UUID) -> bool:
        """Delete ProjectDoc by ID."""
        result = await db.execute(
            delete(ProjectDoc).where(ProjectDoc.id == id)
        )
        await db.commit()
        return result.rowcount > 0
```

**Patterns**:
- All methods are `async`
- Use `select()` for queries, `delete()` for deletions
- `model_dump()` converts Pydantic to dict
- `exclude_unset=True` for partial updates (only update provided fields)
- `db.refresh(project_doc)` loads updated values from database
- `create()` accepts both `project_id` and `data` to properly set the foreign key

[Source: architecture/coding-standards.md#repository-layer]

---

### Testing Strategy

**Unit Tests with Mocked DB**:

From [testing-strategy.md](../architecture/testing-strategy.md#unit-tests):

```python
import pytest
from unittest.mock import AsyncMock, MagicMock
from uuid import uuid4

from app.routers.project_docs import create_project_doc
from app.schemas.project_doc import ProjectDocCreate

@pytest.mark.asyncio
async def test_create_project_doc_success():
    """Test creating ProjectDoc with valid data."""
    # Arrange
    mock_db = AsyncMock()
    mock_repo = AsyncMock()
    project_id = uuid4()
    project_doc_data = ProjectDocCreate(
        name="Test Docs",
        description="Test",
        github_url="https://github.com/user/repo",
        github_folder_path="docs"
    )
    expected_project_doc = MagicMock(
        id=uuid4(),
        project_id=project_id,
        name="Test Docs",
        description="Test",
        github_url="https://github.com/user/repo",
        github_folder_path="docs"
    )
    mock_repo.create.return_value = expected_project_doc

    # Act
    result = await create_project_doc(project_id, project_doc_data, mock_db)

    # Assert
    assert result.name == "Test Docs"
    mock_repo.create.assert_called_once_with(mock_db, project_id, project_doc_data)

@pytest.mark.asyncio
async def test_create_project_doc_invalid_github_url():
    """Test creating ProjectDoc with non-GitHub URL returns validation error."""
    # Arrange
    with pytest.raises(ValueError, match="Must be a GitHub repository URL"):
        ProjectDocCreate(
            name="Test Docs",
            github_url="https://gitlab.com/user/repo",  # Not GitHub
            github_folder_path="docs"
        )
```

**Integration Tests with Test DB**:

```python
import pytest
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from uuid import uuid4

from app.models.project import Project
from app.models.project_doc import ProjectDoc
from app.repositories.project_doc import ProjectDocRepository
from app.schemas.project_doc import ProjectDocCreate

@pytest.fixture
async def test_db():
    """Create test database session."""
    engine = create_async_engine("postgresql+asyncpg://test:test@localhost/test_bmadflow")
    # Create tables, yield session, cleanup
    # (Full implementation in test setup)

@pytest.mark.asyncio
async def test_delete_project_cascades_project_docs(test_db):
    """Test deleting project cascade deletes project_docs."""
    # Create project
    project = Project(name="Test Project")
    test_db.add(project)
    await test_db.commit()

    # Create project_doc
    repo = ProjectDocRepository()
    project_doc = await repo.create(
        test_db,
        project.id,
        ProjectDocCreate(
            name="Test Docs",
            github_url="https://github.com/user/repo"
        )
    )

    # Delete project
    await test_db.delete(project)
    await test_db.commit()

    # Verify project_doc also deleted (CASCADE)
    result = await repo.get_by_id(test_db, project_doc.id)
    assert result is None
```

[Source: architecture/testing-strategy.md#backend-testing]

---

### Alembic Migration Template

**Migration File Structure**:

From [coding-standards.md](../architecture/coding-standards.md#alembic-migrations):

```python
"""create_project_docs_table

Revision ID: def456abc789
Revises: abc123def456  # Previous migration (Story 2.1 projects table)
Create Date: 2025-10-07 14:00:00.000000

Creates the project_docs table for linking GitHub repositories to projects.
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import UUID

# revision identifiers, used by Alembic.
revision = 'def456abc789'
down_revision = 'abc123def456'  # Story 2.1 migration
branch_labels = None
depends_on = None


def upgrade() -> None:
    op.create_table(
        'project_docs',
        sa.Column('id', UUID(as_uuid=True), primary_key=True, server_default=sa.text('uuid_generate_v4()')),
        sa.Column('project_id', UUID(as_uuid=True), nullable=False),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('description', sa.Text, nullable=True),
        sa.Column('github_url', sa.String(512), nullable=False),
        sa.Column('github_folder_path', sa.String(512), nullable=True),
        sa.Column('last_synced_at', sa.DateTime(timezone=True), nullable=True),
        sa.Column('last_github_commit_date', sa.DateTime(timezone=True), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ondelete='CASCADE'),
    )


def downgrade() -> None:
    op.drop_table('project_docs')
```

**Migration Best Practices**:
- Include descriptive docstring explaining purpose
- Use `server_default` for UUID generation and timestamps
- Define foreign key with `ondelete='CASCADE'` for proper cascade behavior
- Keep migrations idempotent (safe to run multiple times)
- Test both `upgrade()` and `downgrade()`
- Document rollback procedures in migration docstring

[Source: architecture/coding-standards.md#migrations]

---

### Project Structure Notes

**File Locations** (from [source-tree.md](../architecture/source-tree.md)):

Story 2.2 follows the same structure as Story 2.1:

```
backend/
├── alembic/
│   └── versions/
│       └── <revision>_create_project_docs_table.py  # New migration
├── app/
│   ├── models/
│   │   ├── __init__.py                              # Import ProjectDoc model
│   │   └── project_doc.py                           # New: ProjectDoc ORM model
│   ├── schemas/
│   │   └── project_doc.py                           # New: Pydantic schemas
│   ├── repositories/
│   │   └── project_doc.py                           # New: Repository layer
│   ├── routers/
│   │   └── project_docs.py                          # New: API router
│   └── main.py                                      # Modified: Register project_docs router
└── tests/
    ├── test_project_docs.py                         # New: Unit tests
    └── integration/
        └── test_project_docs_integration.py         # New: Integration tests
```

**Key Alignment Points**:
- Models follow naming convention: `project_doc.py` (snake_case)
- Router uses plural: `project_docs.py`
- Repository follows singular: `project_doc.py` (repository for ProjectDoc entity)
- Integration tests under `tests/integration/` directory
- Router registered in `app/main.py` similar to projects router

[Source: architecture/source-tree.md]

---

### Code Quality Checks

**Before Committing**:

From [coding-standards.md](../architecture/coding-standards.md#code-quality):

```bash
# Format code
black backend/app/models/project_doc.py backend/app/routers/project_docs.py

# Lint code
ruff check backend/app/models/project_doc.py backend/app/routers/project_docs.py --fix

# Run tests
pytest backend/tests/test_project_docs.py -v

# Check test coverage
pytest backend/tests/test_project_docs.py --cov=app.routers.project_docs --cov-report=term-missing
```

**Expected Output**:
- Black: "All done! ✨"
- Ruff: No errors
- pytest: All tests pass
- Coverage: >80%

[Source: architecture/coding-standards.md#quality-tools]

---

### Learnings from Story 2.1

From [Story 2.1 Dev Agent Record](./2.1-create-project-database-schema-api.md#dev-agent-record):

**Key Insights**:
1. **Comment out future relationships**: ProjectDoc → Document relationship should be commented out (Story 2.4 implements Document model)
2. **Enable uuid-ossp extension**: Migration should include `CREATE EXTENSION IF NOT EXISTS "uuid-ossp"` if not already enabled (may already be enabled from Story 2.1)
3. **Test cascade deletes**: Integration tests should verify Project deletion cascades to ProjectDocs
4. **Module-level mocking**: Use `@patch.object` for mocking repositories in unit tests for cleaner test isolation

**Story 2.1 Testing Results**:
- Unit tests: 7 tests, all passing (97% coverage)
- Integration tests: 6 tests, all passing
- No refactoring needed during QA review (excellent code quality)

These patterns should be replicated for Story 2.2.

[Source: docs/stories/2.1-create-project-database-schema-api.md]

---

## Testing

### Testing Standards

From [testing-strategy.md](../architecture/testing-strategy.md):

**Backend Testing Requirements**:

1. **Unit Tests** (`backend/tests/test_project_docs.py`):
   - Location: `backend/tests/`
   - Framework: pytest with pytest-asyncio
   - Coverage target: >80%
   - Mock database sessions using `AsyncMock`
   - Test router logic in isolation
   - Clear Arrange-Act-Assert structure

2. **Integration Tests** (`backend/tests/integration/test_project_docs_integration.py`):
   - Location: `backend/tests/integration/`
   - Use real test database (`test_bmadflow`)
   - Verify end-to-end repository behavior
   - Test database constraints (foreign keys, NOT NULL)
   - Test cascade deletes (Project → ProjectDoc)
   - Verify ordering behavior (created_at DESC)

3. **Test Fixtures** (`backend/tests/conftest.py`):
   - `db_session`: Test database session fixture
   - Use PostgreSQL test database (not SQLite) for pgvector compatibility
   - Clean up after each test (drop tables)

4. **Running Tests**:
   ```bash
   # Unit tests
   pytest backend/tests/test_project_docs.py -v

   # Integration tests
   pytest backend/tests/integration/test_project_docs_integration.py -v

   # All tests with coverage
   pytest backend/tests/ -v --cov=app --cov-report=term-missing
   ```

5. **Test Coverage Requirements**:
   - Minimum: 80% for routers, repositories, services
   - Edge cases: 404 errors, validation errors, cascade deletes
   - Positive and negative test cases for all endpoints

[Source: architecture/testing-strategy.md#backend-testing]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | 1.0 | Story 2.2 created | Bob (Scrum Master) |
| 2025-10-07 | 1.1 | Story 2.2 implementation completed with test fixture enhancement | James (Dev Agent) |

---

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

No debug logs required. Development proceeded smoothly following Story 2.1 patterns.

### Completion Notes

**Implementation Summary:**
- All 8 tasks completed successfully
- 100% test coverage achieved (10 unit tests, 7 integration tests)
- All code formatted with Black and linted with Ruff (0 errors)
- OpenAPI documentation verified at `/docs`

**Key Implementation Details:**
1. **Pydantic HttpUrl Conversion**: Discovered that Pydantic `HttpUrl` type needed explicit `str()` conversion in repository layer for database storage. Solution documented in `project_doc.py` repository.

2. **Folder Path Normalization**: Implemented Pydantic field validator to strip leading/trailing slashes from `github_folder_path` for consistency.

3. **Cascade Delete Verified**: Integration tests confirm that deleting a Project cascades to all related ProjectDocs (CASCADE constraint working as expected).

4. **GitHub URL Validation**: Custom Pydantic validator ensures only `github.com` or `www.github.com` URLs are accepted, rejecting other git hosts.

5. **Test Fixture Improvement**: Enhanced `conftest.py` to use transaction rollback for test isolation, preventing test data accumulation. Each test now runs in an isolated transaction that is automatically rolled back, ensuring clean test state. This improvement also benefits Story 2.1 tests.

**Test Results:**
- Unit Tests: 10/10 passed, 100% router coverage
- Integration Tests: 7/7 passed
- Total: 17/17 tests passing
- Build: Clean (Black + Ruff)
- Migration: Tested forward and rollback successfully

**No Issues Encountered:**
- Story 2.1 patterns were followed successfully
- No regression in existing tests
- All acceptance criteria met

### File List

**New Files:**
- `backend/alembic/versions/598c0bae7623_create_project_docs_table.py` - Alembic migration
- `backend/app/models/project_doc.py` - ProjectDoc SQLAlchemy model
- `backend/app/schemas/project_doc.py` - Pydantic request/response schemas
- `backend/app/repositories/project_doc.py` - ProjectDoc repository layer
- `backend/app/routers/project_docs.py` - ProjectDoc API router
- `backend/tests/test_project_docs.py` - Unit tests (10 tests)
- `backend/tests/integration/test_project_docs_integration.py` - Integration tests (7 tests)

**Modified Files:**
- `backend/app/models/__init__.py` - Imported ProjectDoc model
- `backend/app/models/project.py` - Added `project_docs` relationship
- `backend/app/main.py` - Registered project_docs router
- `backend/tests/conftest.py` - Enhanced test fixture with transaction rollback for test isolation

---

## QA Results

_To be populated by QA Agent after story implementation_
